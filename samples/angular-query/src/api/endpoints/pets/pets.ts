/**
 * Generated by orval v8.0.0-rc.4 üç∫
 * Do not edit manually.
 * Swagger Petstore
 * OpenAPI spec version: 1.0.0
 */
import {
  HttpClient
} from '@angular/common/http';

import {
  computed,
  inject,
  signal
} from '@angular/core';
import type {
  Signal
} from '@angular/core';

import {
  injectMutation,
  injectQuery
} from '@tanstack/angular-query-experimental';
import type {
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  MutationFunction,
  QueryKey
} from '@tanstack/angular-query-experimental';

import {
  lastValueFrom
} from 'rxjs';

import type {
  CreatePetsBody,
  Error,
  ListPetsParams,
  Pet,
  Pets,
  SearchPetsParams
} from '../../model';





/**
 * @summary search by query params
 */
export const searchPets = (
    http: HttpClient,
    params: SearchPetsParams, options?: Record<string, any>
): Promise<Pets> => {
    
    return lastValueFrom(http.get<Pets>(
      `/search`,{
    ...options,
        params: {...params, ...options?.["params"]},}
    ));
  }




export const getSearchPetsQueryKey = (params?: Signal<SearchPetsParams>,) => {
    return [
    `/search`, ...(params ? [params] : [])
    ] as const;
    }

    


export type SearchPetsQueryResult = NonNullable<Awaited<ReturnType<typeof searchPets>>>
export type SearchPetsQueryError = Error


/**
 * @summary search by query params
 */

export function injectSearchPets<TData = Awaited<ReturnType<typeof searchPets>>, TError = Error>(
 params: Signal<SearchPetsParams>, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof searchPets>>, TError, TData>, fetch?: Record<string, any>}
  
 ): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {
  const http = inject(HttpClient);

  const {query: userQueryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey = getSearchPetsQueryKey(params);

  const queryOptions = {
    queryKey,
    queryFn: ({ signal }) => searchPets(http, params(), { signal, ...fetchOptions }),
    ...userQueryOptions
  } as CreateQueryOptions<Awaited<ReturnType<typeof searchPets>>, TError, TData>;

  const query = injectQuery(() => ({ ...queryOptions })) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  Object.defineProperty(query, 'queryKey', { value: queryOptions.queryKey, writable: true, enumerable: true, configurable: true });

  return query;
}




/**
 * @summary List all pets
 */
export const listPets = (
    http: HttpClient,
    params?: ListPetsParams, options?: Record<string, any>
): Promise<Pets> => {
    
    return lastValueFrom(http.get<Pets>(
      `/pets`,{
    ...options,
        params: {...params, ...options?.["params"]},}
    ));
  }




export const getListPetsQueryKey = (params?: Signal<ListPetsParams>,) => {
    return [
    `/pets`, ...(params ? [params] : [])
    ] as const;
    }

    


export type ListPetsQueryResult = NonNullable<Awaited<ReturnType<typeof listPets>>>
export type ListPetsQueryError = Error


/**
 * @summary List all pets
 */

export function injectListPets<TData = Awaited<ReturnType<typeof listPets>>, TError = Error>(
 params?: Signal<ListPetsParams>, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>, fetch?: Record<string, any>}
  
 ): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {
  const http = inject(HttpClient);

  const {query: userQueryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey = getListPetsQueryKey(params);

  const queryOptions = {
    queryKey,
    queryFn: ({ signal }) => listPets(http, params?.(), { signal, ...fetchOptions }),
    ...userQueryOptions
  } as CreateQueryOptions<Awaited<ReturnType<typeof listPets>>, TError, TData>;

  const query = injectQuery(() => ({ ...queryOptions })) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  Object.defineProperty(query, 'queryKey', { value: queryOptions.queryKey, writable: true, enumerable: true, configurable: true });

  return query;
}




/**
 * @summary Create a pet
 */
export const createPets = (
    http: HttpClient,
    createPetsBody: CreatePetsBody, options?: Record<string, any>
): Promise<void> => {
    
    return lastValueFrom(http.post<void>(
      `/pets`,
      createPetsBody,options
    ));
  }





    export type CreatePetsMutationResult = NonNullable<Awaited<ReturnType<typeof createPets>>>
    export type CreatePetsMutationBody = CreatePetsBody
    export type CreatePetsMutationError = Error

    /**
 * @summary Create a pet
 */
export const injectCreatePets = <TError = Error,
    TContext = unknown>(options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof createPets>>, TError,{data: CreatePetsBody}, TContext>, fetch?: Record<string, any>}
 ): CreateMutationResult<
        Awaited<ReturnType<typeof createPets>>,
        TError,
        {data: CreatePetsBody},
        TContext
      > => {
      const http = inject(HttpClient);

      const mutationKey = ['createPets'];
const {mutation: userMutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPets>>, {data: CreatePetsBody}> = (props) => {
        const {data} = props ?? {};

        return createPets(http, data,fetchOptions)
      }

      const mutationOptions = {
        mutationFn,
        ...userMutationOptions
      };

      return injectMutation(() => ({ ...mutationOptions }));
    }
    /**
 * @summary Info for a specific pet
 */
export const showPetById = (
    http: HttpClient,
    petId: string, options?: Record<string, any>
): Promise<Pet> => {
    
    return lastValueFrom(http.get<Pet>(
      `/pets/${petId}`,options
    ));
  }




export const getShowPetByIdQueryKey = (petId?: Signal<string>,) => {
    return [
    `/pets/${petId}`
    ] as const;
    }

    


export type ShowPetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof showPetById>>>
export type ShowPetByIdQueryError = Error


/**
 * @summary Info for a specific pet
 */

export function injectShowPetById<TData = Awaited<ReturnType<typeof showPetById>>, TError = Error>(
 petId: Signal<string>, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>, fetch?: Record<string, any>}
  
 ): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {
  const http = inject(HttpClient);

  const {query: userQueryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey = getShowPetByIdQueryKey(petId);

  const queryOptions = {
    queryKey,
    queryFn: ({ signal }) => showPetById(http, petId(), { signal, ...fetchOptions }),
    enabled: computed(() => !!(petId())), ...userQueryOptions
  } as CreateQueryOptions<Awaited<ReturnType<typeof showPetById>>, TError, TData>;

  const query = injectQuery(() => ({ ...queryOptions })) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  Object.defineProperty(query, 'queryKey', { value: queryOptions.queryKey, writable: true, enumerable: true, configurable: true });

  return query;
}




/**
 * @summary Info for a specific pet
 */
export const showPetText = (
    http: HttpClient,
    petId: string, options?: Record<string, any>
): Promise<string> => {
    
    return lastValueFrom(http.get(
      `/pets/${petId}/text`,{
        responseType: 'text',
    ...options,}
    ));
  }




export const getShowPetTextQueryKey = (petId?: Signal<string>,) => {
    return [
    `/pets/${petId}/text`
    ] as const;
    }

    


export type ShowPetTextQueryResult = NonNullable<Awaited<ReturnType<typeof showPetText>>>
export type ShowPetTextQueryError = Error


/**
 * @summary Info for a specific pet
 */

export function injectShowPetText<TData = Awaited<ReturnType<typeof showPetText>>, TError = Error>(
 petId: Signal<string>, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof showPetText>>, TError, TData>, fetch?: Record<string, any>}
  
 ): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {
  const http = inject(HttpClient);

  const {query: userQueryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey = getShowPetTextQueryKey(petId);

  const queryOptions = {
    queryKey,
    queryFn: ({ signal }) => showPetText(http, petId(), { signal, ...fetchOptions }),
    enabled: computed(() => !!(petId())), ...userQueryOptions
  } as CreateQueryOptions<Awaited<ReturnType<typeof showPetText>>, TError, TData>;

  const query = injectQuery(() => ({ ...queryOptions })) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  Object.defineProperty(query, 'queryKey', { value: queryOptions.queryKey, writable: true, enumerable: true, configurable: true });

  return query;
}




/**
 * Upload image of the pet.
 * @summary Uploads an image.
 */
export const uploadFile = (
    http: HttpClient,
    petId: number,
    uploadFileBody: Blob, options?: Record<string, any>
): Promise<void> => {
    
    return lastValueFrom(http.post<void>(
      `/pet/${petId}/uploadImage`,
      uploadFileBody,options
    ));
  }





    export type UploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFile>>>
    export type UploadFileMutationBody = Blob
    export type UploadFileMutationError = void | Error

    /**
 * @summary Uploads an image.
 */
export const injectUploadFile = <TError = void | Error,
    TContext = unknown>(options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof uploadFile>>, TError,{petId: number;data: Blob}, TContext>, fetch?: Record<string, any>}
 ): CreateMutationResult<
        Awaited<ReturnType<typeof uploadFile>>,
        TError,
        {petId: number;data: Blob},
        TContext
      > => {
      const http = inject(HttpClient);

      const mutationKey = ['uploadFile'];
const {mutation: userMutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadFile>>, {petId: number;data: Blob}> = (props) => {
        const {petId,data} = props ?? {};

        return uploadFile(http, petId,data,fetchOptions)
      }

      const mutationOptions = {
        mutationFn,
        ...userMutationOptions
      };

      return injectMutation(() => ({ ...mutationOptions }));
    }
    /**
 * Download image of the pet.
 * @summary Download an image.
 */
export const downloadFile = (
    http: HttpClient,
    petId: number, options?: Record<string, any>
): Promise<Blob> => {
    
    return lastValueFrom(http.get(
      `/pet/${petId}/downloadImage`,{
        responseType: 'blob',
    ...options,}
    ));
  }




export const getDownloadFileQueryKey = (petId?: Signal<number>,) => {
    return [
    `/pet/${petId}/downloadImage`
    ] as const;
    }

    


export type DownloadFileQueryResult = NonNullable<Awaited<ReturnType<typeof downloadFile>>>
export type DownloadFileQueryError = void | Error


/**
 * @summary Download an image.
 */

export function injectDownloadFile<TData = Awaited<ReturnType<typeof downloadFile>>, TError = void | Error>(
 petId: Signal<number>, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof downloadFile>>, TError, TData>, fetch?: Record<string, any>}
  
 ): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {
  const http = inject(HttpClient);

  const {query: userQueryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey = getDownloadFileQueryKey(petId);

  const queryOptions = {
    queryKey,
    queryFn: ({ signal }) => downloadFile(http, petId(), { signal, ...fetchOptions }),
    enabled: computed(() => !!(petId())), ...userQueryOptions
  } as CreateQueryOptions<Awaited<ReturnType<typeof downloadFile>>, TError, TData>;

  const query = injectQuery(() => ({ ...queryOptions })) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  Object.defineProperty(query, 'queryKey', { value: queryOptions.queryKey, writable: true, enumerable: true, configurable: true });

  return query;
}




